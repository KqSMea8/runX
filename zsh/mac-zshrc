#!/usr/bin/env bash

xnotic() {
	echo
	echo ${1}
	echo
}

cdf() {
	target=$(osascript -e 'tell application "Finder" to if (count of Finder windows) > 0 then get POSIX path of (target of front Finder window as text)')
	if [ "$target" != "" ]; then
		cd "$target"
		pwd
	else
		echo 'No Finder window found' >&2
	fi
}

o() {
	case "${1}" in
	go)
		code $(echo $GOPATH | cut -f ${2} -d ":")
		;;
	gox)
		export GOPATH=${2}:$GOPATH
		code ${2}
		;;
	*)
		code ${1}
		;;
	esac
}

_prlctl_get_ip_by_host() {
	local HOST_NAME=${1}
	[ -z "${HOST_NAME}" ] && xnotic "empty host name." && return
	prlctl exec ${HOST_NAME} ip addr show | grep -Eo 'inet (10.*)\/24' | cut -d ' ' -f 2 | cut -d '/' -f1
}

_check_pvm_is_exist() {
	local HOST_NAME=${1}
	[ -z "${HOST_NAME}" ] && xnotic "empty host name." && return 1
	$(prlctl list "${HOST_NAME}" >/dev/null 2>&1) && return 0
	return 1
}

_check_pvm_is_alive() {
	local HOST_NAME=${1}
	[ -z "${HOST_NAME}" ] && xnotic "empty host name." && return 1

	_check_pvm_is_exist "${HOST_NAME}" || return 1
	local PVM_RUN_INFO="$(prlctl list ${HOST_NAME})"
	# declare -A MAP
	if [ $(echo ${PVM_RUN_INFO} | grep "running" | grep -Eo "${HOST_NAME}$") ]; then
		return 0
	elif [ $(echo ${PVM_RUN_INFO} | grep "stopped" | grep -Eo "${HOST_NAME}$") ]; then
		return 1
	fi
}

_waiting_til_done() {
	until "$@" >/dev/null 2>&1; do
		sleep 1
		echo -n "."
	done
}

i() {
	while getopts "t:d:s:c:r" OPTS; do
		case "${OPTS}" in
		t)
			OLD_IFS=${IFS}
			IFS=',| |;' read -rA HOST_NAMES <<<"${OPTARG}"
			for HOST_NAME in ${HOST_NAMES}; do
				prlctl stop "${HOST_NAME}" &
			done
			IFS=${OLD_IFS}
			;;
		d)
			OLD_IFS=${IFS}
			IFS=',| |;' read -rA HOST_NAMES <<<"${OPTARG}"
			for HOST_NAME in ${HOST_NAMES}; do
				if _check_pvm_is_alive "${HOST_NAME}"; then
					prlctl stop "${HOST_NAME}" &
					xnotic "waiting for ${HOST_NAME} stopping."
					xnotic "deleting ..."
					_waiting_til_done prlctl delete "${HOST_NAME}"
				else
					if ! _check_pvm_is_exist "${HOST_NAME}"; then
						xnotic "there is no pvm named ${HOST_NAME}"
					else
						prlctl delete "${HOST_NAME}" &
					fi
				fi
			done
			IFS=${OLD_IFS}
			;;
		s)
			OLD_IFS=${IFS}
			IFS=',| |;' read -rA HOST_NAMES <<<"${OPTARG}"
			for HOST_NAME in ${HOST_NAMES}; do
				prlctl start "${HOST_NAME}" &
			done
			IFS=${OLD_IFS}
			;;
		c)
			echo "${OPTS}"
			echo "${OPTIND}"
			echo "${OPTARG}"
			;;
		r)
			${PRLCTL_HOME}/runX nx >/dev/null 2>${PRLCTL_HOME}/runnig.err &
			;;
		\?)
			echo "
  usage:
	i -t pvm		# stop a pvm
	i -d pvm 		# delete a pvm
			"
			;;
		esac
		return
	done

	local TO_HOST=${1}
	local PVM_RUN_INFO="$(prlctl list ${TO_HOST})"

	if [ $(echo ${PVM_RUN_INFO} | grep "running" | grep -Eo "${TO_HOST}$") ]; then
		ssh z@$(_prlctl_get_ip_by_host ${TO_HOST})
	elif [ $(echo ${PVM_RUN_INFO} | grep "stopped" | grep -Eo "${TO_HOST}$") ]; then
		prlctl start "${TO_HOST}"

		xnotic "start check if the vms ${TO_HOST} is already started."
		_waiting_til_done prlctl exec "${TO_HOST}" ip addr show

		xnotic "waite for the ssh port open."

		local CHECK_HOST=$(_prlctl_get_ip_by_host ${TO_HOST})
		local CHECK_PORT=22
		_waiting_til_done nc -z ${CHECK_HOST} ${CHECK_PORT}
		ssh z@${CHECK_HOST}
	else
		xnotic "nothing to do with: ${TO_HOST}"
	fi
}

alias og='o go'
