#!/usr/bin/env bash

xnotic() {
	echo
	echo ${1}
	echo
}

cdf() {
	target=$(osascript -e 'tell application "Finder" to if (count of Finder windows) > 0 then get POSIX path of (target of front Finder window as text)')
	if [ "$target" != "" ]; then
		cd "$target"
		pwd
	else
		echo 'No Finder window found' >&2
	fi
}

o() {
	case "${1}" in
	go)
		code $(echo $GOPATH | cut -f ${2} -d ":")
		;;
	gox)
		export GOPATH=${2}:$GOPATH
		code ${2}
		;;
	*)
		code ${1}
		;;
	esac
}

_prlctl_get_ip_by_host() {
	local HOST_NAME=${1}
	[ -z "${HOST_NAME}" ] && xnotic "empty host name." && return
	prlctl exec ${HOST_NAME} ip addr show | grep -Eo 'inet (10.*)\/24' | cut -d ' ' -f 2 | cut -d '/' -f1
}

_check_pvm_is_exist() {
	local HOST_NAME=${1}
	[ -z "${HOST_NAME}" ] && xnotic "empty host name." && return 1
	$(prlctl list "${HOST_NAME}" >/dev/null 2>&1) && return 0
	return 1
}

_check_pvm_is_alive() {
	local HOST_NAME=${1}
	[ -z "${HOST_NAME}" ] && xnotic "empty host name." && return 1

	_check_pvm_is_exist "${HOST_NAME}" || return 1
	local PVM_RUN_INFO="$(prlctl list ${HOST_NAME})"
	# declare -A MAP
	if [ $(echo ${PVM_RUN_INFO} | grep "running" | grep -Eo "${HOST_NAME}$") ]; then
		return 0
	elif [ $(echo ${PVM_RUN_INFO} | grep "stopped" | grep -Eo "${HOST_NAME}$") ]; then
		return 1
	fi
}

_waiting_til_done() {
	echo "$@"
	echo
	echo
	VM_STATUS=$("$@") || VM_STATUS=1

	until $([ -z ${VM_STATUS} ]); do
		VM_STATUS=$("$@") || VM_STATUS=1
		sleep 1
		echo -n "."
	done
}

i() {
	while getopts "t:d:s:" OPTS; do
		case "${OPTS}" in
		t)
			prlctl stop "${OPTARG}" &
			;;
		d)
			local HOST_NAME=${OPTARG}
			if _check_pvm_is_alive "${HOST_NAME}"; then
				prlctl stop "${HOST_NAME}" &
				xnotic "waiting for ${HOST_NAME} stopping."
				xnotic "deleting ..."
				_waiting_til_done prlctl delete "${HOST_NAME}" >/dev/null 2>&1
				# VM_STATUS=$(prlctl delete "${HOST_NAME}" >/dev/null 2>&1) || VM_STATUS=1
				# until $([ -z ${VM_STATUS} ]); do
				# 	# when pvm started, exec ip command eixt with code 0, but $() express return empty
				# 	# so VM_STATUS is empty, we use -z as a until end condition.
				# 	VM_STATUS=$(prlctl delete "${HOST_NAME}" >/dev/null 2>&1) || VM_STATUS=1
				# 	sleep 1
				# 	echo -n "."
				# done
			else
				if ! _check_pvm_is_exist "${HOST_NAME}"; then
					xnotic "there is no pvm named ${HOST_NAME}"
				else
					prlctl delete "${HOST_NAME}" &
				fi
			fi
			;;
		s)
			prlctl start "${OPTARG}" &
			;;
		c)
			echo "${OPTS}"
			echo "${OPTIND}"
			echo "${OPTARG}"
			;;
		\?)
			echo "
  usage:
	i -t pvm		# stop a pvm
	i -d pvm 		# delete a pvm
			"
			;;
		esac
		return
	done

	local TO_HOST=${1}
	local PVM_RUN_INFO="$(prlctl list ${TO_HOST})"

	if [ $(echo ${PVM_RUN_INFO} | grep "running" | grep -Eo "${TO_HOST}$") ]; then
		ssh z@$(_prlctl_get_ip_by_host ${TO_HOST})
	elif [ $(echo ${PVM_RUN_INFO} | grep "stopped" | grep -Eo "${TO_HOST}$") ]; then
		prlctl start "${TO_HOST}"

		xnotic "start check if the vms ${TO_HOST} is already started."
		# @TODO _waiting_til_done is not work for prlctl.
		# @TODO non of echo in _waiting_til_done would be print.
		# _waiting_til_done prlctl exec "${TO_HOST}" ip addr show >/dev/null 2>&1
		# set -e make the shell script exit when any error happens. but except '&&' and '||'
		VM_STATUS=$(prlctl exec "${TO_HOST}" ip addr show >/dev/null 2>&1) || VM_STATUS=1

		until $([ -z ${VM_STATUS} ]); do
			# when pvm started, exec ip command eixt with code 0, but $() express return empty
			# so VM_STATUS is empty, we use -z as a until end condition.
			VM_STATUS=$(prlctl exec "${TO_HOST}" ip addr show >/dev/null 2>&1) || VM_STATUS=1
			sleep 1
			echo -n "."
		done

		xnotic "waite for the ssh port open."

		local CHECK_HOST=$(_prlctl_get_ip_by_host ${TO_HOST})
		local CHECK_PORT=22
		_waiting_til_done nc -z ${CHECK_HOST} ${CHECK_PORT} >/dev/null 2>&1
		ssh z@${CHECK_HOST}
	else
		xnotic "nothing to do with: ${TO_HOST}"
	fi
}

alias og='o go'
